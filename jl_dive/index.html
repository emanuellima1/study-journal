<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Julia Deep Dive - My Study Journal</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Julia Deep Dive";
        var mkdocs_page_input_path = "jl_dive.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> My Study Journal
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Programming Languages</span></p>
              <ul>
                  <li class="toctree-l1"><a class="" href="../bash.md">Bash</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../c/">C</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../cpp/">C++</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../cython/">Cython</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../go.md">Go</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../jl/">Julia</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../py/">Python</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../rust/">Rust</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">DevOps</span></p>
              <ul>
                  <li class="toctree-l1"><a class="" href="../ansible.md">Ansible</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../ci.md">Continuous Integration/Delivery</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../aws.md">AWS</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../azure.md">Azure</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../docker.md">Docker</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../git.md">Git</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../gitops.md">GitOps & ArgoCD</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../jenkins.md">Jenkins</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../kata.md">Kata Containers</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../k8s.md">Kubernetes</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../micro.md">Microservices</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../openshift.md">OpenShift</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../podman.md">Podman</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../re.md">Release Engineering</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../serverless.md">Serverless</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../sre.md">Site Reliability Engineering</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../tekton.md">Tekton</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../terraform.md">Terraform</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Linux</span></p>
              <ul>
                  <li class="toctree-l1"><a class="" href="../sysadmin.md">System Administration</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Software Engineering</span></p>
              <ul>
                  <li class="toctree-l1"><a class="" href="../agile.md">Agile Methods</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">My Study Journal</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Julia Deep Dive</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="julia-deep-dive">Julia Deep Dive</h1>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#julia-deep-dive">Julia Deep Dive</a></li>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#basics">Basics</a></li>
<li><a href="#data-types-and-structures">Data Types and Structures</a><ul>
<li><a href="#scalar-types">Scalar Types</a></li>
<li><a href="#const-values">Const values</a></li>
<li><a href="#basic-math">Basic Math</a></li>
<li><a href="#strings">Strings</a></li>
<li><a href="#arrays">Arrays</a></li>
<li><a href="#multidimensional-and-nested-arrays">Multidimensional and Nested Arrays</a></li>
<li><a href="#tuples">Tuples</a></li>
<li><a href="#named-tuples">Named Tuples</a></li>
<li><a href="#dictionaries">Dictionaries</a></li>
<li><a href="#sets">Sets</a></li>
<li><a href="#memory-and-copy">Memory and Copy</a></li>
<li><a href="#random-numbers">Random Numbers</a></li>
</ul>
</li>
<li><a href="#basic-syntax">Basic Syntax</a><ul>
<li><a href="#functions">Functions</a></li>
</ul>
</li>
<li><a href="#custom-types">Custom Types</a></li>
<li><a href="#io">I/O</a></li>
<li><a href="#metaprogramming">Metaprogramming</a></li>
<li><a href="#exceptions">Exceptions</a></li>
<li><a href="#repl">REPL</a></li>
<li><a href="#dataframes">DataFrames</a></li>
<li><a href="#references">References</a></li>
</ul>
<h2 id="basics">Basics</h2>
<p>The minimal "hello world" program:</p>
<pre><code class="language-julia"># Single line comment

#=
Multi-line comment
=#

println(&quot;Hello, World!&quot;)
</code></pre>
<p>Indentation doesn't matter. Indexing starts at 1, like Matlab and Octave.
In the REPL, by pressing "]" you can enter the "package mode", where you can write commands that manage the packages you have or want. Some commands:</p>
<ul>
<li><code>status</code>: Retrieves a list with name and versions of locally installed packages</li>
<li><code>update</code>: Updates your local index of packages and all your local packages to the latest version</li>
<li><code>add myPkg</code>: Automatically downloads and installs a package</li>
<li><code>rm myPkg</code>: Removes a package and all its dependent packages that has been installed automatically only for it</li>
<li><code>add pkgName#master</code>: Checkouts the master branch of a package (and free pkgName returns to the released version)</li>
<li><code>add pkgName#branchName</code>: Checkout a specific branch</li>
<li><code>add git@github.com:userName/pkgName.jl.git</code>: Checkout a non registered pkg</li>
</ul>
<p>To use a package on a Julia script, write <code>using [package]</code> at the beginning of the script. To use a package without populating the namespace, write <code>import [package]</code>. But then, you will have to use the functions as <code>[package].function()</code>. You can also include local Julia scripts as such: <code>include("my_script.jl")</code>.</p>
<p>I think that <code>using [package]</code> is bad practice because it pollutes the namespace. The best way to import a package is this:</p>
<pre><code class="language-julia"># Importing the JSON package through an alias
import JSON as J

# Using:
J.print(Dict(&quot;Hello, &quot; =&gt; &quot;World!&quot;))
</code></pre>
<p>A particular class of variable names is one that contains only underscores. These identifiers can only be assigned values, which are immediately discarded, and cannot therefore be used to assign values to other variables (i.e., they cannot be used as rvalues) or use the last value assigned to them in any way.</p>
<h2 id="data-types-and-structures">Data Types and Structures</h2>
<p>Some built-in data types and structures of the Julia language:</p>
<h3 id="scalar-types">Scalar Types</h3>
<p>The usual scalar types are present: Int64, UInt128, BigInt, Float64, Char and Bool.</p>
<h3 id="const-values">Const values</h3>
<p>Constant values are declared as such:</p>
<pre><code class="language-julia">const foo = 1234
</code></pre>
<h3 id="basic-math">Basic Math</h3>
<p>Complex numbers can be defined like so, with <code>im</code> being the square root of -1:</p>
<pre><code class="language-julia">a = 1 + 2im
</code></pre>
<p>Exact integer division can be done like this:</p>
<pre><code class="language-julia">a = 2 // 3
</code></pre>
<p>All standard basic mathematical arithmetic operators are supported (+, -, *, /, %, ^).
Mathematical constants can be used like so:</p>
<pre><code class="language-julia">MathConstants.e
MathConstants.pi
</code></pre>
<p>Natural exponentiation can be done like this:</p>
<pre><code class="language-julia"> a = exp(b)
</code></pre>
<h3 id="strings">Strings</h3>
<p>Strings are immutable. We use single quote for chars and double quote for strings. A string on a single row can be created using a single pair of double quotes, while a string on multiple rows can use a triple pair of double quotes:</p>
<pre><code class="language-julia">a = &quot;a string&quot;
b = &quot;a string\non multiple rows\n&quot;
c = &quot;&quot;&quot;
    a string
    on multiple rows
    &quot;&quot;&quot;
</code></pre>
<p>Some string operations are also present, like:</p>
<ul>
<li><code>split</code>: Separates string into other strings based on a char. Default char is whitespace.</li>
<li><code>join([string1, string2], "")</code>: Concatenates strings with a certain string.</li>
<li><code>replace(s, "toSearch" =&gt; "toReplace")</code>: Replaces occurrences on the string s.</li>
<li><code>strip(s)</code>: Remove leading and trailing whitespaces.</li>
</ul>
<p>Other ways to concatenate strings:</p>
<ul>
<li>Concatenation operator: <code>*</code>;</li>
<li>Function <code>string(string1,string2,string3)</code>;</li>
<li>Interpolate string variables in a bigger one using the dollar symbol: <code>a = "$str1 is a string and $(myobject.int1) is an integer"</code>.</li>
</ul>
<p>To convert strings representing numbers to integers or floats, use <code>myInt = parse(Int64,"2017")</code>. To convert integers or floats to strings, use <code>myString = string(123)</code>.</p>
<p>You can broadcast a function to work over a collection (instead of a scalar) using the dot (.) operator. For example, to broadcast <code>parse</code> to work over an array:</p>
<pre><code class="language-julia">myNewList = parse.(Float64,[&quot;1.1&quot;,&quot;1.2&quot;])
</code></pre>
<h3 id="arrays">Arrays</h3>
<p>Arrays are N-dimensional mutable containers. Ways to create one:</p>
<ul>
<li><code>a = []</code> or <code>a = Int64[]</code> or <code>a = Array{T,1}()</code> or <code>a = Vector{T}()</code>: Empty array. Array{} is the constructor, T is the type and Vector{} is an alias for 1 dimensional arrays.</li>
<li><code>a = zeros(5)</code> or <code>a = zeros(Int64,5)</code> or <code>a = ones(5)</code>: Array of zeros (or ones)</li>
<li><code>a = fill(j, n)</code>: n-element array of identical j elements</li>
<li><code>a = rand(n)</code>: n-element array of random numbers</li>
<li><code>a = [1,2,3]</code>: Explicit construction (column vector).</li>
<li><code>a = [1 2 3]</code>:  Row vector (this is a two-dimensional array where the first dimension is made of a single row)</li>
<li><code>a = [10, "foo", false]</code>: Can be of mixed types, but will be much slower</li>
</ul>
<p>If you need to store different types on a data structure, better to use an Union: <code>a = Union{Int64,String,Bool}[10, "Foo", false]</code>.
Some operations on arrays:</p>
<ul>
<li><code>a[1]</code>: Access element.</li>
<li><code>a[from:step:to]</code>: Slice</li>
<li><code>collect(myiterator)</code>: Transforms an iterator in an array.</li>
<li><code>y = vcat(2015, 2025:2028, 2100)</code>: Initialize an array expanding the elements. 2025:2028 means [2025, 2026, 2027, 2028].</li>
<li><code>push!(a,b)</code>: Append b to the end of a</li>
<li><code>append!(a,b)</code>: Append the elements of b to the end of a. If b is scalar, append b to the end of a.</li>
<li><code>a = [1,2,3]; b = [4,5]; c = vcat(1,a,b)</code>: Concatenation of arrays.</li>
<li><code>pop!(a)</code>: Remove element from the end of a.</li>
<li><code>popfirst!(a)</code>: Remove first element of a.</li>
<li><code>deleteat!(a, pos)</code>: Remove element at position pos from array a.</li>
<li><code>pushfirst!(a,b)</code>: Add b at the beginning of array a.</li>
<li><code>sort!(a) or sort(a)</code>: Sorting, depending on whether we want to modify or not the original array.</li>
<li><code>unique!(a) or unique(a)</code>: Remove duplicates</li>
<li><code>a[end:-1:1]</code>: Reverses array a.</li>
<li><code>in(1, a)</code>: Checks for existence.</li>
<li><code>length(a)</code>: Length of array.</li>
<li><code>a...</code>: The “splat” operator. Converts the values of an array into function parameters</li>
<li><code>maximum(a) or  max(a...)</code>: Maximum value. max returns the maximum value between the given arguments.</li>
<li><code>minimum(a) or  min(a...)</code>: Minimum value. min returns the minimum value between the given arguments.</li>
<li><code>isempty(a)</code>: Checks if an array is empty.</li>
<li><code>reverse(a)</code>: Reverses an array.</li>
<li><code>sum(a)</code>: Return the summation of the elements of a.</li>
<li><code>cumsum(a)</code>: Return the cumulative sum of each element of a (returns an array).</li>
<li><code>empty!(a)</code>: Empty an array (works only for column vectors, not for row vectors).</li>
<li><code>b = vec(a)</code>: Transform row vectors into column vectors.</li>
<li><code>shuffle(a) or shuffle!(a)</code>: Random-shuffle the elements of a (requires <code>using Random</code> before).</li>
<li><code>findall(x -&gt; x == value, myArray)</code>: Find a value in an array and return its indexes.</li>
<li><code>enumerate(a)</code>: Get (index,element) pairs. Return an iterator to tuples, where the first element is the index of each element of the array a and the second is the element itself.</li>
<li><code>zip(a,b)</code>: Get (a_element, b_element) pairs. Return an iterator to tuples made of elements from each of the arguments</li>
</ul>
<p>Functions that end in '!' modify their first argument.</p>
<p>Map applies a function to every element in the input arrays:</p>
<pre><code class="language-julia">map(func, my_array)
</code></pre>
<p>Filter takes a collection of values, <code>xs</code>, and returns a subset, <code>ys</code>, of those
values. The specific values from <code>xs</code> that are included in the resulting <code>ys</code> are deter-
mined by the predicate <code>p</code>. A predicate is a function that takes some value and always returns a Boolean value:</p>
<pre><code class="language-julia">ys = filter(p, xs)
</code></pre>
<p>Reduce takes some binary function, <code>g</code>, as the first argument, and then uses this function to combine the elements in the collection, <code>xs</code>, provided as the second argument:</p>
<pre><code class="language-julia">y = reduce(g, xs)
</code></pre>
<p>Mapreduce can be understood as <code>reduce(g, map(f, xs))</code>.</p>
<h3 id="multidimensional-and-nested-arrays">Multidimensional and Nested Arrays</h3>
<p>A matrix is an array of arrays that have the same length. The main difference between a matrix and an array of arrays is that, with a matrix, the number of elements on each column (row) must be the same and rules of linear algebra apply.</p>
<p>Attention: <strong>Julia is column-major</strong></p>
<p>Ways to create one:</p>
<ul>
<li><code>a = Matrix{T}()</code></li>
<li><code>a = Array{T}(undef, 0, 0, 0)</code></li>
<li><code>a = [[1,2,3] [4,5,6]]</code>: [[elements of the first column] [elements of the second column] ...].</li>
<li><code>a = hcat(col1, col2)</code>. By the columns.</li>
<li><code>a = [1 4; 2 5; 3 6]</code>: [elements of the first row; elements of the second row; ...].</li>
<li><code>a = vcat(row1, row2)</code>: By the rows.</li>
<li><code>a = zeros(2,3)</code> or <code>a = ones(2,3)</code>: A 2x3 matrix filled with zeros or ones.</li>
<li><code>a = fill(j, 2, 3)</code>: A 2x3 matrix of identical j elements</li>
<li><code>a = rand(2, 3)</code>: A 2x3 matrix of random numbers</li>
</ul>
<p>Attention to the difference:</p>
<ul>
<li><code>a = [[1,2,3],[4,5,6]]</code>: creates a 1-dimensional array with 2-elements.</li>
<li><code>a = [[1,2,3] [4,5,6]]</code>: creates a 2-dimensional array (a matrix with 2 columns) with three elements (scalars).</li>
</ul>
<p>Access the elements with <code>a[row,col]</code>.
You can also make a boolean mask and apply to the matrix:</p>
<pre><code class="language-julia">a = [[1,2,3] [4,5,6]]
mask = [[true,true,false] [false,true,false]]
println(a[mask])
# Will print [1, 2, 5]. Always flattened.
</code></pre>
<p>Other useful operations:</p>
<ul>
<li><code>size(a)</code>: Returns a tuple with the sizes of the n dimensions.</li>
<li><code>ndims(a)</code>: Returns the number of dimensions of the array.</li>
<li><code>a'</code>: Transpose operator.</li>
<li><code>reshape(a, nElementsDim1, nElementsDim2)</code>: Reshape the elements of a in a new n-dimensional array with the dimensions given.</li>
<li><code>dropdims(a, dims=(dimToDrop1,dimToDrop2))</code>: Remove the specified dimensions, provided that the specified dimension has only a single element</li>
</ul>
<p>These last three operations performe only a shallow copy (a view) on the matrix, so if the underlying matrix changes, the view also changes. Use <code>collect(reshape/dropdims/transpose)</code> to force a deep copy.</p>
<h3 id="tuples">Tuples</h3>
<p>Tuples are an immutable collection of elements. Initialize with <code>a = (1,2,3)</code> or <code>a = 1,2,3</code>. Tuples can be unpacked like so: <code>var1, var2 = (x,y)</code>. And you can convert a tuple into a vector like this: <code>v = collect(a)</code>.</p>
<h3 id="named-tuples">Named Tuples</h3>
<p>Named tuples are immutable collections of items whose position in the collection (index) can be identified not only by their position but also by their name.</p>
<ul>
<li><code>nt = (a=1, b=2.5)</code>: Define a NamedTuple</li>
<li><code>nt.a</code>: Access the elements with the dot notation</li>
<li><code>keys(nt)</code>: Return a tuple of the keys</li>
<li><code>values(nt)</code>: Return a tuple of the values</li>
<li><code>collect(nt)</code>: Return an array of the values</li>
<li><code>pairs(nt)</code>: Return an iterable of the pairs (key,value). Useful for looping: <code>for (k,v) in pairs(nt) [...] end</code></li>
</ul>
<h3 id="dictionaries">Dictionaries</h3>
<p>Dictionaries are mutable mappings from keys to values. Ways to create one:</p>
<ul>
<li><code>mydict = Dict{T,U}()</code></li>
<li><code>mydict = Dict('a'=&gt;1, 'b'=&gt;2, 'c'=&gt;3)</code></li>
</ul>
<p>Useful operations:</p>
<ul>
<li><code>mydict[key] = value</code>: Add pairs to the dictionary</li>
<li><code>mydict[key]</code>: Look up value. If it doesn't exist, raises error.</li>
<li><code>get(mydict,'a',0)</code>: Look up value with a default value for non-existing key.</li>
<li><code>keys(mydict)</code>: Get all keys. Results in an iterator. Use collect() to transform into array.</li>
<li><code>values(mydict)</code>: Iterator of all the values.</li>
<li><code>haskey(mydict, 'a')</code>: Checks if a key exists.</li>
<li><code>in(('a' =&gt; 1), mydict)</code>: Checks if a given key/value pair exists.</li>
<li><code>delete!(amydict,'akey')</code>: Delete the pair with the specified key from the dictionary.</li>
</ul>
<p>You can iterate over both keys and values:</p>
<pre><code class="language-julia">for (k,v) in mydict
   println(&quot;$k is $v&quot;)
end
</code></pre>
<h3 id="sets">Sets</h3>
<p>A set is a mutable collection of unordered and unique values. Ways to create one:</p>
<ul>
<li><code>a = Set{T}()</code>: Empty set</li>
<li><code>a = Set([1,2,2,3,4])</code>: Initialize with values</li>
<li><code>push!(s, 5)</code>: Add elements</li>
<li><code>delete!(s,1)</code>: Delete elements</li>
<li><code>intersect(set1,set2)</code>, <code>union(set1,set2)</code>, <code>setdiff(set1,set2)</code>: Intersection, union, and difference.</li>
</ul>
<h3 id="memory-and-copy">Memory and Copy</h3>
<p>Shallow copy (copy of the memory address only) is the default in Julia. Some observations:</p>
<ul>
<li><code>a = b</code>: This is a name binding. It binds the entity referenced by <code>b</code> to the <code>a</code> identifier. If <code>b</code> rebinds to some other object, <code>a</code> remains referenced to the original object. If the object referenced by <code>b</code> mutates, so does those referenced by <code>a</code>.</li>
<li>When a variable receives other variable: Basic types (Float64, Int64, String) are deep copied. Containers are shallow copied.</li>
<li><code>copy(x)</code>: Simple types are deep copied, containers of simple types are deep copied, containers of containers, the content is shadow copied (the content of the content is only referenced, not copied).</li>
<li><code>deepcopy(x)</code>: Everything is deep copied recursively.</li>
</ul>
<p>Observations on types:</p>
<p>You can check if two objects have the same values with <code>==</code> and if two objects are actually the same with <code>===</code>.</p>
<p>To cast an object into a different type:</p>
<pre><code class="language-julia">convertedObj = convert(T,x)
</code></pre>
<h3 id="random-numbers">Random Numbers</h3>
<ul>
<li><code>rand()</code>: Random float in [0,1].</li>
<li><code>rand(a:b)</code>: Random integer in [a,b].</li>
<li><code>rand(a:0.01:b)</code>: Random float in [a,b] with "precision" to the second digit.</li>
<li><code>rand(2,3)</code>: Random 2x3 matrix.</li>
<li><code>rand(DistributionName([distribution parameters]))</code>: Random float in [a,b] using a particular distribution (Normal, Poisson,...). Requires the Distributions package.</li>
<li><code>rand(Uniform(a,b))</code>: Random float in [a,b] using an uniform distribution.</li>
<li><code>import Random:seed!; seed!(1234)</code>: Sets a seed.</li>
</ul>
<h2 id="basic-syntax">Basic Syntax</h2>
<p>The typical control flow is present:</p>
<pre><code class="language-julia"># 1 and 5 are included on this range
for i = 1:5
    println(i)
end

for j in [1, 2, 3]
    println(j)
end

# Nested loops:
for i = 1:2, j = 3:4
    println((i, j))
end

i = 0
while i &lt; 5
    println(i)
    global i += 1
end

if x &lt; y
    println(&quot;x is less than y&quot;)
elseif x &gt; y
    println(&quot;x is greater than y&quot;)
else
    println(&quot;x is equal to y&quot;)
end
</code></pre>
<p>There are list comprehensions:</p>
<pre><code class="language-julia">[myfunction(i) for i in [1,2,3]]

[x + 2y for x in [10,20,30], y in [1,2,3]]

mydict = Dict()
[mydict[i]=value for (i, value) in enumerate(mylist)]
# enumerate returns an iterator to tuples with the index and the value of elements in an array

[students[name] = sex for (name,sex) in zip(names,sexes)]
# zip returns an iterator of tuples pairing two or multiple lists, e.g. [(&quot;Marc&quot;,&quot;M&quot;),(&quot;Anne&quot;,&quot;F&quot;)]

map((n,s) -&gt; students[n] = s, names, sexes)
# map applies a function to a list of arguments
</code></pre>
<p>The ternary operator is present:</p>
<pre><code class="language-julia">a ? b : c
# If a is true, then b, else c
</code></pre>
<p>The usual logic operators exist:</p>
<ul>
<li>And: <code>&amp;&amp;</code></li>
<li>Or:  <code>||</code></li>
<li>Not: <code>!</code></li>
</ul>
<h3 id="functions">Functions</h3>
<p>Functions can be declared like so:</p>
<pre><code class="language-julia">function f(x)
    x+2
end
</code></pre>
<p>Function arguments are normally specified by position (positional arguments). However, if a semicolon (;) is used in the parameter list of the function definition, the arguments listed after that semicolon must be specified by name (keyword arguments).</p>
<pre><code class="language-julia">function func(a,b=1;c=2)
    # blabla
end

# Optionally restrict the types of argument the function should accept by annotating the parameter with the type:
function func(a::Int64,b::Int64=1;c::Int64=2)
    # blabla
end
</code></pre>
<p>Function that can operate on some types but not others:</p>
<pre><code class="language-julia"># This function can operate on Float64 or on a Vector of Float64.
function func(par::Union{Float64, Vector{Float64}})
    # In the body we check the type using typeof()
end
</code></pre>
<p>Function with variable number of arguments:</p>
<pre><code class="language-julia"># The splat operator (...) can specify a variable number of arguments in the parameter declaration
function func(a, args...)
    # The parameter that uses the ellipsis must be the last one
    # In the body we use args as an iterator
end
</code></pre>
<p>Julia has multiple-dispatch. If you declare the same function with different arguments, the compiler will choose the correct function to call based on the arguments you passed.
You can also do type parametrization on functions:</p>
<pre><code class="language-julia">function f(x::T)
    x+2
end

myfunction(x::T, y::T2, z::T2) where {T &lt;: Number, T2} = 5x + 5y + 5z
</code></pre>
<p>Functions are objects that can be assigned to new variables, returned, or nested:</p>
<pre><code class="language-julia">f(x) = 2x   # define a function f inline
a = f(2)    # call f and assign the return value to a
a = f       # bind f to a new variable name (it's not a deep copy)
a(5)        # call again the (same) function
</code></pre>
<p>Functions work on new local variables, known only inside the function itself. Assigning the variable to another object will not influence the original variable. But if the object bound with the variable is mutable (e.g., an array), the mutation of this object will apply to the original variable as well:</p>
<pre><code class="language-julia">function f(x,y)
    x = 10
    y[1] = 10
end

x = 1
y = [1,1]

# x will not change, but y will now be [10,1]
f(x,y)
</code></pre>
<p>Functions that change their arguments have their name, by convention, followed by an '!'. The first parameter is, still by convention, the one that will be modified.</p>
<p>Anonymous functions can be declared like so:</p>
<pre><code class="language-julia">(x, y) -&gt; x^2 + 2y - 1
# you can assign an anonymous function to a variable.
</code></pre>
<p>You can broadcast a function to work over all the elements of an array:</p>
<pre><code class="language-julia">myArray = broadcast(i -&gt; replace(i, &quot;x&quot; =&gt; &quot;y&quot;), myArray)

# Or like this:
f = i -&gt; replace(i, &quot;x&quot; =&gt; &quot;y&quot;)
myArray = f.(myArray)
</code></pre>
<p>Functions whose name is a singular symbol can be used on an infix or prefix form:</p>
<pre><code class="language-julia">5 + 3

+(5, 3)
</code></pre>
<h2 id="custom-types">Custom Types</h2>
<p>There are two type operators:</p>
<ul>
<li>The <code>::</code> operator is used to constrain an object of being of a given type. For example, <code>a::B</code> means “a must be of type B”.</li>
<li>The <code>&lt;:</code> operator has a similar meaning, but it’s a bit more relaxed in the sense that the object can be of any subtypes of the given type. For example, <code>A&lt;:B</code> means “A must be a subtype of B”, that is, B is the “parent” type and A is its “child” type.</li>
</ul>
<p>You can define structures like this:</p>
<pre><code class="language-julia"># Structs are immutable by default. Hence the mutable keyword.
# Immutable structs are much faster.
mutable struct MyStruct
  property1::Int64
  property2::String
end

# Parametrized:
mutable struct MyStruct2{T&lt;:Number}
 property1::Int64
 property2::String
 property3::T
end

# Instantiating and accessing attribute:
myObject = MyStruct(20,&quot;something&quot;)
a = myObject.property1 # 20
</code></pre>
<p>Attention to this:</p>
<ul>
<li><code>a::B</code>: Means "a must be of type B".</li>
<li><code>A&lt;:B</code>: Means "A must be a subtype of B".</li>
</ul>
<p>An example of object orientation in Julia:</p>
<pre><code class="language-julia">struct Person
  myname::String
  age::Int64
end

struct Shoes
    shoesType::String
    colour::String
end

struct Student
    s::Person
    school::String
    shoes::Shoes
end

function printMyActivity(self::Student)
    println(&quot;I study at $(self.school) school&quot;)
end

struct Employee
    s::Person
    monthlyIncomes::Float64
    company::String
    shoes::Shoes
end

function printMyActivity(self::Employee)
    println(&quot;I work at $(self.company) company&quot;)
end

gymShoes = Shoes(&quot;gym&quot;,&quot;white&quot;)
proShoes = Shoes(&quot;classical&quot;,&quot;brown&quot;)

Marc = Student(Person(&quot;Marc&quot;,15),&quot;Divine School&quot;,gymShoes)
MrBrown = Employee(Person(&quot;Brown&quot;,45),1200.0,&quot;ABC Corporation Inc.&quot;, proShoes)

printMyActivity(Marc)
printMyActivity(MrBrown)
</code></pre>
<p>Observations:</p>
<ul>
<li>Functions are not associated to a type. Do not call a function over a method (<code>myobj.func(x,y)</code>) but rather you pass the object as a parameter (<code>func(myobj, x, y)</code>)</li>
<li>Julia doesn't use inheritance, but rather composition (a field of the subtype is of the higher type, allowing access to its fields).</li>
</ul>
<p>Some useful functions:</p>
<ul>
<li><code>supertype(MyType)</code>: Returns the parent types of a type.</li>
<li><code>subtypes(MyType)</code>: Lists all children of a type.</li>
<li><code>fieldnames(MyType)</code>: Queries all the fields of a structure.</li>
<li><code>isa(obj,MyType)</code>: Checks if obj is of type MyType.</li>
<li><code>typeof(obj)</code>: Returns the type of obj.</li>
</ul>
<h2 id="io">I/O</h2>
<p>Opening a file is similar to Python. The file closes automatically in the end:</p>
<pre><code class="language-julia"># Write to file
open(&quot;file.txt&quot;, &quot;w&quot;) do f  # &quot;w&quot; for writing, &quot;r&quot; for read and &quot;a&quot; for append.
    write(f, &quot;test\n&quot;)      # \n for newline
end

# Read whole file:
open(&quot;file.txt&quot;, &quot;r&quot;) do f
  filecontent = read(f,String)
  print(filecontent)
end

# Read line by line:
open(&quot;file.txt&quot;, &quot;r&quot;) do f
    for ln in eachline(f)
        println(ln)
    end
end

# Read, keeping track of line numbers:
open(&quot;file.txt&quot;, &quot;r&quot;) do f
    for (i,ln) in enumerate(eachline(f))
        println(&quot;$i $ln&quot;)
    end
end
</code></pre>
<h2 id="metaprogramming">Metaprogramming</h2>
<p>TODO</p>
<h2 id="exceptions">Exceptions</h2>
<p>Exceptions are similar to Python:</p>
<pre><code class="language-julia">try
    # Some dangerous code...
catch
    # What to do if an error happens, most likely send an error message using:
    error(&quot;My detailed message&quot;)
end

# Check for specific exception:
function volume(region, year)
    try
        return data[&quot;volume&quot;,region,year]
    catch e
        if isa(e, KeyError)
            return missing
        end
        rethrow(e)
    end
end
</code></pre>
<h2 id="repl">REPL</h2>
<p>One can load a Julia file into the REPL to experiment with it:</p>
<pre><code class="language-julia">include(&quot;my_file.jl&quot;)
</code></pre>
<h2 id="dataframes">DataFrames</h2>
<p>Examples:</p>
<pre><code class="language-julia"># Read data from a CSV
using DataFrames, CSV
myData = CSV.read(file, DataFrame, header = 1, copycols = true, types=Dict(:column_name =&gt; Int64))

# Read data from the web:
using DataFrames, HTTP, CSV
resp = HTTP.request(&quot;GET&quot;, &quot;https://data.cityofnewyork.us/api/views/kku6-nxdu/rows.csv?accessType=DOWNLOAD&quot;)
df = CSV.read(IOBuffer(String(resp.body)))

# Read data from spreadsheet:
using DataFrames, OdsIO
df = ods_read(&quot;spreadsheet.ods&quot;;sheetName=&quot;Sheet2&quot;,retType=&quot;DataFrame&quot;,range=((tl_row,tl_col),(br_row,br_col)))

# Empty df:
df = DataFrame(A = Int64[], B = Float64[])
</code></pre>
<p>Insights about the data:</p>
<ul>
<li><code>first(df, 6)</code></li>
<li><code>show(df, allrows=true, allcols=true)</code></li>
<li><code>last(df, 6)</code></li>
<li><code>describe(df)</code></li>
<li><code>unique(df.fieldName)</code> or <code>[unique(c) for c in eachcol(df)]</code></li>
<li><code>names(df)</code>: Returns array of column names</li>
<li><code>[eltype(col) for col = eachcol(df)]</code>: Returns an array of column types</li>
<li><code>size(df)</code>: (r,c); <code>size(df)[1]</code>: (r); <code>size(df)[2]</code>: (c).</li>
<li><code>ENV["LINES"] = 60</code>: Change the default number of lines before the content is - truncated (default 30).</li>
<li><code>for c in eachcol(df)</code>: Iterates over each column.</li>
<li><code>for r in eachrow(df)</code>: iterates over each row.</li>
</ul>
<p>To query the data from a DataFrame you can use the Query package. Examples:</p>
<pre><code class="language-julia">using Query

dfOut = @from i in df begin
           @where i.col1 &gt; 1
           @select {aNewColName=i.col1, i.col3}
           @collect DataFrame
        end
 dfOut = @from i in df begin
            @where i.value != 1 &amp;&amp; i.cat1 in [&quot;green&quot;,&quot;pink&quot;]
            @select i
            @collect DataFrame
        end
</code></pre>
<h2 id="references">References</h2>
<ul>
<li><a href="https://syl1.gitbook.io/julia-language-a-concise-tutorial/">Julia language: a concise tutorial</a>.</li>
<li>Antonello Lobianco. Julia Quick Syntax Reference. 1st Edition. Apress.</li>
</ul>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
